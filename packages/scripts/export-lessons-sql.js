#!/usr/bin/env node
/**
 * Export lessons in data/lessons/* to SQL (INSERT ... ON CONFLICT DO UPDATE)
 * Usage: node packages/scripts/export-lessons-sql.js > /tmp/lessons.sql
 * Then:  psql "$DATABASE_URL" -f /tmp/lessons.sql
 */
const fs = require('fs');
const path = require('path');

function readJSON(p, fb=null){ try { return JSON.parse(fs.readFileSync(p,'utf-8')); } catch { return fb; } }
function toPlain(value){
  if (value === null || value === undefined) return value;
  return JSON.parse(JSON.stringify(value));
}
function sqlEscapeLiteral(str){ return String(str).replace(/'/g, "''"); }
function sqlJSON(obj){ return `'${sqlEscapeLiteral(JSON.stringify(obj||null))}'::jsonb`; }

function header(){
  return [
    '-- SQL generated by export-lessons-sql.js (prefers Postgres as source)',
    'BEGIN;'
  ].join('\n');
}

function ddl(){
  return `
CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE EXTENSION IF NOT EXISTS pg_trgm;

CREATE TABLE IF NOT EXISTS "Lesson" (
  id text PRIMARY KEY,
  lesson_no int NOT NULL,
  title text NOT NULL,
  level text,
  tags jsonb DEFAULT '[]',
  duration int,
  audio_url text NOT NULL,
  status text DEFAULT 'draft' CHECK (status IN ('draft','published')),
  version int DEFAULT 1,
  published boolean DEFAULT false,
  published_at timestamptz,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

CREATE TABLE IF NOT EXISTS "Transcript" (
  lesson_id text PRIMARY KEY REFERENCES "Lesson"(id) ON DELETE CASCADE,
  segments jsonb NOT NULL
);

CREATE TABLE IF NOT EXISTS "Vocab" (
  lesson_id text PRIMARY KEY REFERENCES "Lesson"(id) ON DELETE CASCADE,
  cards jsonb NOT NULL
);

CREATE TABLE IF NOT EXISTS "Practice" (
  lesson_id text PRIMARY KEY REFERENCES "Lesson"(id) ON DELETE CASCADE,
  cloze jsonb,
  essay jsonb
);

CREATE TABLE IF NOT EXISTS "LessonHistory" (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  lesson_id text REFERENCES "Lesson"(id) ON DELETE CASCADE,
  version int NOT NULL,
  reason text,
  snapshot jsonb NOT NULL,
  created_at timestamptz DEFAULT now()
);

CREATE TABLE IF NOT EXISTS "LessonPodcast" (
  lesson_id text PRIMARY KEY REFERENCES "Lesson"(id) ON DELETE CASCADE,
  meta jsonb,
  transcript jsonb
);
`; }

function upsertLesson(meta){
  const id = sqlEscapeLiteral(String(meta.id||meta.lesson_no));
  const lesson_no = Number(meta.lesson_no||meta.lessonNo||meta.id||0);
  const title = sqlEscapeLiteral(meta.title||`Lesson ${id}`);
  const level = meta.level? `'${sqlEscapeLiteral(meta.level)}'` : 'NULL';
  const tags = sqlJSON(meta.tags||[]);
  const duration = Number(meta.duration||0) || 0;
  const audio_url = sqlEscapeLiteral(meta.audio_url||meta.audioUrl||'');
  const published = !!meta.published;
  const version = Number(meta.version||1) || 1;
  const status = published ? 'published' : 'draft';
  const publishedAtRaw = meta.published_at || meta.publishedAt || meta.publish_at || null;
  let published_at = 'NULL';
  if (publishedAtRaw) {
    const publishedDate = new Date(publishedAtRaw);
    if (!Number.isNaN(publishedDate.getTime())) {
      published_at = `'${sqlEscapeLiteral(publishedDate.toISOString())}'::timestamptz`;
    }
  }
  const updatedAtRaw = meta.updated_at || meta.updatedAt || null;
  let updated_at = 'now()';
  if (updatedAtRaw) {
    const updatedDate = new Date(updatedAtRaw);
    if (!Number.isNaN(updatedDate.getTime())) {
      updated_at = `'${sqlEscapeLiteral(updatedDate.toISOString())}'::timestamptz`;
    }
  }
  return `INSERT INTO "Lesson" (id, lesson_no, title, level, tags, duration, audio_url, status, version, published, published_at, updated_at)
VALUES ('${id}', ${lesson_no}, '${title}', ${level}, ${tags}, ${duration}, '${audio_url}', '${status}', ${version}, ${published}, ${published_at}, ${updated_at})
ON CONFLICT (id) DO UPDATE SET
  lesson_no=EXCLUDED.lesson_no,
  title=EXCLUDED.title,
  level=EXCLUDED.level,
  tags=EXCLUDED.tags,
  duration=EXCLUDED.duration,
  audio_url=EXCLUDED.audio_url,
  status=EXCLUDED.status,
  version=EXCLUDED.version,
  published=EXCLUDED.published,
  published_at=EXCLUDED.published_at,
  updated_at=now();`;
}

function upsertTranscript(id, obj){
  return `INSERT INTO "Transcript" (lesson_id, segments) VALUES ('${sqlEscapeLiteral(id)}', ${sqlJSON(obj.segments||[])})
ON CONFLICT (lesson_id) DO UPDATE SET segments=EXCLUDED.segments;`;
}

function upsertVocab(id, obj){
  return `INSERT INTO "Vocab" (lesson_id, cards) VALUES ('${sqlEscapeLiteral(id)}', ${sqlJSON(obj.cards||[])})
ON CONFLICT (lesson_id) DO UPDATE SET cards=EXCLUDED.cards;`;
}

function upsertPractice(id, p){
  const cloze = p && p.cloze ? sqlJSON(p.cloze) : 'NULL';
  const essay = p && p.essay ? sqlJSON(p.essay) : 'NULL';
  return `INSERT INTO "Practice" (lesson_id, cloze, essay) VALUES ('${sqlEscapeLiteral(id)}', ${cloze}, ${essay})
ON CONFLICT (lesson_id) DO UPDATE SET cloze=EXCLUDED.cloze, essay=EXCLUDED.essay;`;
}

function upsertPodcast(id, p){
  const meta = p && p.meta ? sqlJSON(p.meta) : 'NULL';
  const transcript = p && p.transcript ? sqlJSON(p.transcript) : 'NULL';
  return `INSERT INTO "LessonPodcast" (lesson_id, meta, transcript) VALUES ('${sqlEscapeLiteral(id)}', ${meta}, ${transcript})
ON CONFLICT (lesson_id) DO UPDATE SET meta=EXCLUDED.meta, transcript=EXCLUDED.transcript;`;
}

function footer(){ return 'COMMIT;'; }

function readLessonsFromFiles(){
  const root = path.join(process.cwd(), 'data', 'lessons');
  let ids = [];
  try {
    ids = fs.readdirSync(root).filter((f)=>/^[0-9]+$/.test(f));
  } catch {
    return [];
  }
  ids.sort((a,b)=>Number(a)-Number(b));
  const entries = [];
  for (const id of ids){
    const dir = path.join(root, id);
    const meta = readJSON(path.join(dir, 'meta.json'), null);
    if (!meta) { entries.push({ id, meta: null, warning: `-- skip ${id}: no meta.json` }); continue; }
    meta.id = id; meta.lesson_no = meta.lesson_no || Number(id);
    const tran = readJSON(path.join(dir, 'transcript.json'), null);
    const vocab = readJSON(path.join(dir, 'vocab.json'), null);
    const practice = {
      cloze: readJSON(path.join(dir, 'practice', 'cloze.json'), null),
      essay: readJSON(path.join(dir, 'practice', 'essay.json'), null)
    };
    const podcast = {
      meta: readJSON(path.join(dir, 'podcast_meta.json'), null),
      transcript: readJSON(path.join(dir, 'podcast_transcript.json'), null),
    };
    entries.push({
      id,
      meta,
      transcript: tran,
      vocab,
      practice,
      podcast: podcast.meta || podcast.transcript ? podcast : null,
    });
  }
  return entries;
}

async function fetchLessonsFromDb(){
  let PrismaClient;
  try {
    ({ PrismaClient } = require('@prisma/client'));
  } catch {
    return null;
  }
  let prisma;
  try {
    prisma = new PrismaClient();
  } catch (err) {
    console.warn('[export-lessons-sql] Prisma client init failed, fallback to files:', err?.message || err);
    return null;
  }
  try {
    const rows = await prisma.lesson.findMany({
      orderBy: { lesson_no: 'asc' },
      include: { transcript: true, vocab: true, practice: true, podcast: true },
    });
    return rows.map((row) => {
      const meta = {
        id: row.id,
        lesson_no: row.lesson_no,
        lessonNo: row.lesson_no,
        title: row.title,
        level: row.level,
        tags: Array.isArray(row.tags) ? row.tags : toPlain(row.tags) || [],
        duration: row.duration || 0,
        audio_url: row.audio_url || '',
        status: row.status || (row.published ? 'published' : 'draft'),
        version: row.version || 1,
        published: !!row.published,
        published_at: row.published_at ? row.published_at.toISOString() : null,
        updated_at: row.updated_at ? row.updated_at.toISOString() : null,
      };
      const transcript = row.transcript ? { segments: toPlain(row.transcript.segments) || [] } : null;
      const vocab = row.vocab ? { cards: toPlain(row.vocab.cards) || [] } : null;
      const practice = row.practice
        ? {
            cloze: toPlain(row.practice.cloze) || null,
            essay: toPlain(row.practice.essay) || null,
          }
        : null;
      const podcast = row.podcast
        ? {
            meta: toPlain(row.podcast.meta) || null,
            transcript: toPlain(row.podcast.transcript) || null,
          }
        : null;
      return { id: row.id, meta, transcript, vocab, practice, podcast };
    });
  } catch (err) {
    console.warn('[export-lessons-sql] DB fetch failed, fallback to files:', err?.message || err);
    return null;
  } finally {
    await prisma.$disconnect().catch(()=>{});
  }
}

async function main(){
  const fromDb = await fetchLessonsFromDb();
  const lessons = fromDb !== null ? fromDb : readLessonsFromFiles();
  const out = [];
  out.push(header());
  out.push(ddl());
  if (fromDb === null) {
    const root = path.join(process.cwd(), 'data', 'lessons');
    if (!fs.existsSync(root)) {
      out.push('-- WARNING: data/lessons directory not found, no lessons exported');
    }
  }
  for (const entry of lessons){
    const { id } = entry;
    const meta = entry.meta;
    if (!meta) { out.push(entry.warning || `-- skip ${id}: missing meta`); continue; }
    out.push(upsertLesson(meta));
    if (entry.transcript) out.push(upsertTranscript(id, entry.transcript));
    if (entry.vocab) out.push(upsertVocab(id, entry.vocab));
    if (entry.practice && (entry.practice.cloze || entry.practice.essay)) out.push(upsertPractice(id, entry.practice));
    if (entry.podcast && (entry.podcast.meta || entry.podcast.transcript)) out.push(upsertPodcast(id, entry.podcast));
  }
  out.push(footer());
  process.stdout.write(out.join('\n\n'));
}

if (require.main === module) {
  main().catch((err) => {
    console.error('[export-lessons-sql] failed:', err);
    process.exit(1);
  });
}
